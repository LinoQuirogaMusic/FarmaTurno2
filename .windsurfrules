Estamos desarrollando MidiMic 2.0, una app Android profesional hecha en Kotlin con Jetpack Compose, evoluciÃ³n de MidiMic 1.

Esta versiÃ³n transforma la voz en eventos MIDI, e incluye:

    Modo tiempo real: canta y se convierte a MIDI en vivo.

    Modo grabaciÃ³n: graba audio, lo transcribe a .midi cuantizado segÃºn una escala personalizada, y lo sube a la nube.

El usuario podrÃ¡ activar:

    CuantizaciÃ³n en el tiempo (ajuste rÃ­tmico en vivo)

    Pitch bend opcional si la frecuencia no coincide con una nota exacta

El envÃ­o de MIDI se podrÃ¡ hacer por:

    USB (Android MIDI API / USB host)

    WiFi (RTP-MIDI o protocolo OSC/UDP personalizado)

El usuario podrÃ¡ definir escalas de notas (mayores, menores, pentatÃ³nicas, o personalizadas).

Los archivos .midi generados podrÃ¡n subirse a la nube (Firebase Storage u otro servicio).

TECNOLOGÃAS POR FUNCIÃ“N
Funcionalidad	TecnologÃ­a sugerida
UI	Jetpack Compose + Material 3
Pitch detection	TarsosDSP (base actual), evaluar crepe-onnx o aubio si se usa NDK o IA ligera
CuantizaciÃ³n rÃ­tmica	Algoritmo propio con temporizador + rejilla (grid)
Pitch bend	CÃ¡lculo de cents + mensaje MIDI pitch bend
ConexiÃ³n MIDI USB	Android MIDI API / UsbMidiDriver
ConexiÃ³n MIDI WiFi	RTP-MIDI (si posible), o protocolo OSC/UDP
GrabaciÃ³n de audio	AudioRecord o MediaRecorder
Exportar archivo .midi	MidiFileWriter o libs compatibles en Android
Subida a la nube	Firebase Storage

ARQUITECTURA BASE (MVVM):

ğŸ“ ui/           â†’ Pantallas en Jetpack Compose
ğŸ“ viewmodel/    â†’ LÃ³gica de presentaciÃ³n
ğŸ“ audio/        â†’ GrabaciÃ³n y pitch detection
ğŸ“ midi/         â†’ GeneraciÃ³n de eventos, cuantizaciÃ³n, exportaciÃ³n
ğŸ“ network/      â†’ EnvÃ­o de MIDI por red local
ğŸ“ usb/          â†’ ComunicaciÃ³n MIDI por USB
ğŸ“ data/         â†’ Escalas, configuraciÃ³n
ğŸ“ cloud/        â†’ Subida de archivos a la nube
ğŸ“ utils/        â†’ Extensiones y helpers

REGLAS TÃ‰CNICAS

    Usa compileDebugKotlin para verificar que todo compile correctamente.

    Si necesitas modificar build.gradle.kts, solo aÃ±ade lo necesario (no cambies lo que ya funciona).

    Usa Coroutines y Flow para flujos de datos reactivos.

    No incluyas comentarios explicativos si el cÃ³digo es evidente. Comenta solo decisiones tÃ©cnicas o funciones futuras.